---
title: "Prova"
author: "Rafael Silva Wagner"
date: "3 de novembro de 2017"
output:
  pdf_document: default
  html_document: default
---


##QUestão 1
```{r packages , cache=FALSE ,message=FALSE,warning=FALSE,results="hide"}
library(BETS)
library(forecast)
library(stats)
library(MTS)
library(xts)
library(tseries)
library(ggplot2)
library(moments)
library(MCMCpack)
library(plot3D)
library(vars)
library(egcm)
library(PerformanceAnalytics)
library(ggfortify)
library(quantmod)
library(mgarchBEKK)
library(quantmod)
library(ccgarch)
library(rmgarch)
library(BatchGetSymbols)
library(gridExtra)
```

Escolhi trabalhar com indices de ações europeias, escolhi elas pois acredito que elas podem conter informações relevantes tanto para análise de correção de erros uma vez que a economia europeia é muito integrada, quanto podem apresentar características relevantes na análise de variancia. Farei as duas questões com os indices da Inglaterra, França, Suíça, Alemanha, Holanda

Comecemos carregandos essas séries

```{r, message=FALSE,warning=FALSE,results="hide"}
#^GDAXI - DAX - Alemanha
#^FTSE - FTSE - Inglaterra
#^AEX - AEX - Holanda
#^FCHI - CAC 40 - França
#^SSMI - SMI - Suíça
symbols <- c("^GDAXI","^FTSE","^AEX","^FCHI","^SSMI")
getSymbols(symbols, src = 'yahoo', from = "2007-01-01",auto.assign = TRUE, warnings = FALSE) 
prices <- merge(AEX,FCHI,FTSE,GDAXI,SSMI)
prices <- prices[,grepl( "Close" , names(prices) )]
#Da uma limpada nos espaços em branco
limpeza<-as.matrix(prices)
impute.mean <- function(x) replace(x, is.na(x) | is.nan(x) | is.infinite(x), mean(x, na.rm = TRUE))
limpeza <- apply(limpeza, 2, impute.mean)
impute.mean <- function(x) replace(x, is.na(x) | is.nan(x) | is.infinite(x), mean(x[!is.na(x) & !is.nan(x) & !is.infinite(x)]))
limpeza <- apply(limpeza, 2, impute.mean)
#devolve as séries limpas para um data.frame
prices<-as.xts(limpeza)
colnames(prices) <- symbols
returns <- na.omit(Return.calculate(prices, method = "log"))*100
```

#Letra a

Começamos plotando as séries antes sem tratamento

```{r}
plot.xts(prices)
```

Vemos que as oscilações realmente parecem ter algum comovimento, vamos agora realizar o teste ADF nessas séries.

```{r}
adf.test(prices[,1])
adf.test(prices[,2])
adf.test(prices[,3])
adf.test(prices[,4])
adf.test(prices[,5])
```

Podemos ver que nenhuma das séries originais é de fato estacionária, nós ja pegamos os log-retornos dessas séries antes, vamos verificar se esse procedimento foi o suficiente para tornar todas as séries estacionárias.

```{r}
adf.test(returns[,1])
adf.test(returns[,2])
adf.test(returns[,3])
adf.test(returns[,4])
adf.test(returns[,5])
```

Elas realmente estão com compotamento estacionário, agora quando quiser me referir as séries originais me referirei ao data frame prices, e quando quiser me referir as series estacionárias me referirei ao data frame returns.

Vamos montar uma tabela descritiva dos retornos e um gráfico deles conjuntamente.

```{r}
summary(data.frame(returns))
autoplot(returns)
plot.xts(returns)
```

Vamos analisar o histograma de cada série individualmente. Conjuntamente solicitarei os 4 primeiros momentos de cada serie.

```{r, warning=FALSE,message=FALSE}
all.moments(returns[,1],order=3)
qplot(returns[,1],qeom="histogram",xlim=c(-5,5),xlab=symbols[1])
all.moments(returns[,2],order=3)
qplot(returns[,2],qeom="histogram",xlim=c(-5,5),xlab=symbols[2])
all.moments(returns[,3],order=3)
qplot(returns[,3],qeom="histogram",xlim=c(-5,5),xlab=symbols[3])
all.moments(returns[,4],order=3)
qplot(returns[,4],qeom="histogram",xlim=c(-5,5),xlab=symbols[4])
all.moments(returns[,5],order=3)
qplot(returns[,5],qeom="histogram",xlim=c(-5,5),xlab=symbols[5])
```


Agora vamos verificar alguns gráficos que expçoe as autocorrelações presentes dentro de cada série.

```{r}
ggtsdisplay(returns[,1],main=symbols[1])
ggtsdisplay(returns[,2],main=symbols[2])
ggtsdisplay(returns[,3],main=symbols[3])
ggtsdisplay(returns[,4],main=symbols[4])
ggtsdisplay(returns[,5],main=symbols[5])
```

#Letra b

Eu espero que essas séries tenham fortissimas relações, a economia europeia é muito relacionada especialmente pelo fato de alguns países que estamos analisando fazerem parte da zona do euro. Ainda aqueles que não fazem parte da zona do euro são muito influenciados por ela pois estão geograficamente muito próximos e tem relações economicas estreitas.

#Letra C

Vamos primeiramente verificar qual seria um bom número de defasagens, pedirei para serem avaliadas as primeiras 10 defasagens e plotarei os critérios de informação calculados.

```{r}
identificando<-VARselect(returns, lag.max=10)
identificando
identificando_criterios<-(data.frame(t(identificando$criteria)))
autoplot(ts(identificando_criterios[,1:3]))
```

Com essas informações e tentando ser parsimonioso escolhi estimar o modelo com 6 defasagens, número ótimo indicado pelo critério de informação bayesiano e pelo hanna-quin.

Vamos estimar esse VAR

```{r}
var_europa <- vars::VAR(returns, 6,type="none")
summary(var_europa)
```


Os resultados foram muito bons, vemos que todas as equações tem um teste F significativo, e alguns R quadrados estão acima de 0.3 que é um volume alto de poder explicativo para variáveis financeiras.
Analisando cada equação individualmente vemos que a frança a suíça e a holanda foram as que conseguiram gerar os maiores R². Quanto a série da Inglaterra e da Alemanha elas foram as com menor variação explicada pelo R², isso possivelmente se deve por essas duas economias serem as maiores da região europeia e não se limitarem a serem influenciadas regionalmente, possivelmente se relacionam melhor com outras grandes economias a nivel mundial e não a nivel continental.

#Letra d

Começaremos plotando as funções impulso resposta.

```{r}
plot(irf(var_europa, n.ahead = 12, boot = TRUE))
```

Como é comum nesse tipo de análise os intervalos de confiança fazem com que poucos períodos tenha funções impulso resposta significativamente diferentes de zero.

Agora façamos os testes para causalidade de Granger

```{r}
causality(var_europa,cause="X.GDAXI")
causality(var_europa,cause="X.FTSE")
causality(var_europa,cause="X.AEX")
causality(var_europa,cause="X.FCHI")
causality(var_europa,cause="X.SSMI")
```


Vemos que todas as variáveis causam e são causadas no sentido de granger tanto no período recente quanto a posteriori, isso confirma minha expectativa da alta correlação dessas variáveis.

#Letra e

Vamos realizar o teste do traço de johansen para cointegração, não colocarei sasonaldiade mas colocarei uma constante, faço isso pois como utilizarei as variáveis cruas pode ser que um intercepto melhore a análise.

```{r}
summary(ca.jo(prices, type = "trace", ecdet = "const",K = 6))
```

Podemos ver pelo teste de Johansen apontou que a 10% de significancia há uma relação de cointegração entre essas variáveis.

#Letra f

Como foi encontrado um vetor de cointegração vamos estimá-lo

```{r}
vecm <- ca.jo(prices, type = "trace", ecdet = "const", K = 6)
vecm.r2 <- cajorls(vecm, r = 1)
summary(vecm.r2$rlm)
```

Podemos ver que a relação de cointegração foi significativa para a inglaterra, holanda e suiça, enquanto para a frança e alemanha não houve significancia da relação de cointegração.

Para aqueles que foram significativos vemos que a suiça tem um coeficiente de ajustamento negativo e a inglaterra e a holanda tem coeficientes positivos indicando que de fato a principal cointegração se da entre essas três variáveis.

##Questão 2

#Letra a

Vou utilizar para modelar cada série individualmente a distribuição t padrão com assimetria o interesse nessa assimetria se da pelos fatos estilizados das séries financeiras indicarem caudas grossas e leve assimetria a esquerda,, fatos estilizados confirmados anteriormente quando verificamos os momentos amostrais das nossas séries. Para estimar a densidade conjunta eu utilizei uma t multivariada devido a possibilidade da curtose ser verificada também na interelação entre as séries.

```{r}
spec1 <- ugarchspec(distribution = "sstd")
mspec <- multispec(c(spec1,spec1,spec1,spec1,spec1))
dcc.spec<-dccspec(mspec,distribution="mvt")
d.fit.2<-dccfit(dcc.spec,returns)
```

#Letra b

Reportamos os parametros estimados

```{r}
d.fit.2
```

#Letra C

Monta um gráfico contendo as variancias condicionais agrupadas.

```{r}
cov.dcc <- rcov(d.fit.2)
var_cov<-as.ts(cbind(cov.dcc[1,1,],cov.dcc[2,2,],cov.dcc[3,3,],cov.dcc[4,4,],cov.dcc[5,5,]))
colnames(var_cov)<-names(returns)
autoplot(var_cov,main="Variâncias",xlab="Períodos",ylab="Variância")
autoplot(as.xts(var_cov),main="Variâncias",xlab="Períodos",ylab="Variância")
```

Monta gráficos que colocam a variância e as covariancias de cada ativo em um gráfico individual

```{r}
covs_cada_ativo<-list()
for (i in 1:5){
  covs_cada_ativo[[i]]<-matrix(0,nrow=nrow(var_cov),ncol=5)
  for(j in 1:5){
    serie<-matrix(cov.dcc[i,j,])
    covs_cada_ativo[[i]][,j]<-serie
  }
  colnames(covs_cada_ativo[[i]])<-paste(symbols[i],symbols)
}
autoplot(as.ts(covs_cada_ativo[[1]]),xlab="Períodos",ylab=paste("Varincia/Covariancias",symbols[1]))
autoplot(as.ts(covs_cada_ativo[[2]]),xlab="Períodos",ylab=paste("Varincia/Covariancias",symbols[2]))
autoplot(as.ts(covs_cada_ativo[[3]]),xlab="Períodos",ylab=paste("Varincia/Covariancias",symbols[3]))
autoplot(as.ts(covs_cada_ativo[[4]]),xlab="Períodos",ylab=paste("Varincia/Covariancias",symbols[4]))
autoplot(as.ts(covs_cada_ativo[[5]]),xlab="Períodos",ylab=paste("Varincia/Covariancias",symbols[5]))
```

Monta um gráfico demonstrando como o relacionamento da matriz de covariancia se da pra cada serie no formato de uma matriz de variancias e covariancias.

```{r}
covariancias<-list()
proxima<-0
for (i in 1:5){
    for(j in 1:5){
    ts<-as.ts(matrix(cov.dcc[i,j,]))
    names<-paste(symbols[i],symbols[j])
    covariancias[[proxima+j]]<-autoplot(ts,main=names)
    }
  proxima<-proxima+5
}

grid.arrange(covariancias[[1]],covariancias[[2]],covariancias[[3]],covariancias[[4]],covariancias[[5]],
             covariancias[[6]],covariancias[[7]],covariancias[[8]],covariancias[[9]],covariancias[[10]],
             covariancias[[11]],covariancias[[12]],covariancias[[13]],covariancias[[14]],covariancias[[15]],
             covariancias[[16]],covariancias[[17]],covariancias[[18]],covariancias[[19]],covariancias[[20]],
             covariancias[[21]],covariancias[[22]],covariancias[[23]],covariancias[[24]],covariancias[[25]],
             ncol=5, nrow=5)
```


#Letra d

Monta um gráfico contendo as correlações condicionais agrupadas.

```{r}
corr.dcc<-rcor(d.fit.2)
var_corr<-as.ts(cbind(corr.dcc[1,2,],corr.dcc[1,3,],corr.dcc[1,4,],corr.dcc[1,5,],
                     corr.dcc[2,3,],corr.dcc[2,4,],corr.dcc[2,5,],
                     corr.dcc[3,4,],corr.dcc[3,5,],
                     corr.dcc[4,5,]))



nomes<-rep("names",times=(ncol(var_corr)))
count<-1
for (i in 2:5){
  for(j in 1:(i-1)){
    nomes[count]<-paste(symbols[i],symbols[j])
    count<-count+1
  }
}
colnames(var_corr)<-nomes
autoplot(var_corr,ylab="Correlações",xlab="Períodos")
```

Monta gráficos que colocam a variancia e as covariancias de cada ativo em um gráfico individual

```{r}

corrs_cada_ativo<-list()
for (i in 1:5){
  corrs_cada_ativo[[i]]<-matrix(0,nrow=nrow(var_corr),ncol=5)
  for(j in 1:5){
    serie<-matrix(corr.dcc[i,j,])
    corrs_cada_ativo[[i]][,j]<-serie
  }
  colnames(corrs_cada_ativo[[i]])<-paste(symbols[i],symbols)
}

for(i in 1:5){
  autoplot(as.ts(corrs_cada_ativo[[i]]),main=paste("Correlações",symbols[i]))
}

autoplot(as.ts(corrs_cada_ativo[[1]]),main=paste("Correlações",symbols[1]),ylab="Correlações",xlab="Períodos")
autoplot(as.ts(corrs_cada_ativo[[2]]),main=paste("Correlações",symbols[2]),ylab="Correlações",xlab="Períodos")
autoplot(as.ts(corrs_cada_ativo[[3]]),main=paste("Correlações",symbols[3]),ylab="Correlações",xlab="Períodos")
autoplot(as.ts(corrs_cada_ativo[[4]]),main=paste("Correlações",symbols[4]),ylab="Correlações",xlab="Períodos")
autoplot(as.ts(corrs_cada_ativo[[5]]),main=paste("Correlações",symbols[5]),ylab="Correlações",xlab="Períodos")
```

Monta um gráfico demonstrando como o relacionamento da matriz de correlações se da pra cada serie individualmente no formato de uma matriz de correlações.

```{r}
correlacoes<-list()
proxima<-0
for (i in 1:5){
    for(j in 1:5){
    ts<-as.ts(matrix(corr.dcc[i,j,]))
    names<-paste(symbols[i],symbols[j])
    correlacoes[[proxima+j]]<-autoplot(ts,main=names)
    }
  proxima<-proxima+5
}

grid.arrange(correlacoes[[1]],correlacoes[[2]],correlacoes[[3]],correlacoes[[4]],correlacoes[[5]],
             correlacoes[[6]],correlacoes[[7]],correlacoes[[8]],correlacoes[[9]],correlacoes[[10]],
             correlacoes[[11]],correlacoes[[12]],correlacoes[[13]],correlacoes[[14]],correlacoes[[15]],
             correlacoes[[16]],correlacoes[[17]],correlacoes[[18]],correlacoes[[19]],correlacoes[[20]],
             correlacoes[[21]],correlacoes[[22]],correlacoes[[23]],correlacoes[[24]],correlacoes[[25]],
             ncol=5, nrow=5)
```

